### For-learning-Go-Tutorial

Go语言是谷歌2009发布的第二款开源编程语言

Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。

因而一直想的是自己可以根据自己学习和使用Go语言编程的心得，写一本Go的书可以帮助想要学习Go语言的初学者快速入门开发和使用！

#### 基本数据类型

Go基本数据类型这块是基础所以需要着重去学习和实践运用。

基本数据类型有：
* [整型](#整型)
* [浮点型](#浮点型)
* [复数](#复数)
* [布尔型](#布尔型)
* [字符串](#字符串)
* [常量](#常量)
* [整型运算](#整型运算)

#### 整型

Go语言同时提供了有符号和无符号类型的整数运算。

```go
有符号整形数类型:
int8,长度:1字节, 取值范围:(-128 ~ 127)
int16,长度:2字节,取值范围:(-32768 ~ 32767）
int32,长度:4字节,取值范围:(-2,147,483,648 ~ 2,147,483,647）
int64.长度:8字节,取值范围:(-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)

无符号整形数类型:
uint8,长度:1字节, 取值范围:(0 ~ 255)
uint16,长度:2字节,取值范围:(0 ~ 65535)
uint32,长度:4字节,取值范围:(0 ~ 4,294,967,295)
uint64.长度:8字节,取值范围:(0 ~ 18,446,744,073,709,551,615)
```

字符是 UTF-8 编码的 Unicode 字符，Unicode 为每一个字符而非字形定义唯一的码值（即一个整数），例如 字符a 在 unicode 字符表是第 97 个字符，所以其对应的数值就是 97，也就是说对于Go语言处理字符时，97 和 a 都是指的是字符a，而 Go 语言将使用数值指代字符时，将这样的数值称呼为 rune 类型。
rune类型是 Unicode 字符类型，和 int32 类型等价，通常用于表示一个 Unicode 码点。rune 和 int32 可以互换使用。
一个Unicode代码点通常由"U+"和一个以十六进制表示法表示的整数表示，例如英文字母'A'的Unicode代码点为"U+0041"。

此外rune类型的值需要由单引号"'"包裹，不过我们还可以用另外几种方式表示: 

<p align="center">
<img width="500" align="center" src="../images/5.jpg" />
</p>

rune类型值的表示中支持几种特殊的字符序列，即:转义符。

<p align="center">
<img width="500" align="center" src="../images/4.jpg" />
</p>

byte是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是 一个小的整数。

uintptr 是一种无符号的整数类型，没有指定具体的bit大小但是足以容纳指针。 uintptr类型只有在底层编程是才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。

此外在这里还需要了解下进制的转换方便以后学习和使用:

```markdown
十进制整数: 使用0-9的数字表示且不以0开头。// 100 123455
八进制整数: 以0开头，0-7的数字表示。 // 0100 0600
十六进制整数: 以0X或者是0x开头，0-9|A-F|a-f组成 //0xff 0xFF12
```
#### 浮点型

浮点型。float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。由于精确度的缘故，你在使用 `==` 或者 `!=` 来比较浮点数时应当非常小心。

```go
浮点型（IEEE-754 标准）:
float32:（+- 1e-45 -> +- 3.4 * 1e38）32位浮点类型

float64:（+- 5 1e-324 -> 107 1e308）64位浮点类型
```
浮点型中指数部分由"E"或"e"以及带正负号的10进制整数表示。例:`3.9E-2`表示浮点数`0.039`。`3.9E+1`表示浮点数39。
有时候浮点数类型值也可以被简化。比如39.0可以被简化为39。0.039可以被简化为.039。在Golang中浮点数的相关部分只能由10进制表示法表示。


#### 复数
```go
复数类型:
complex64: 由两个float32类型的值分别表示复数的实数部分和虚数部分

complex128: 由两个float64类型的值表示复数的实数部分和虚数部分
```
复数类型的值一般由浮点数表示的实数部分、加号"+"、浮点数表示的虚数部分以及小写字母"i"组成，例如：
```go
 var x complex128 = complex(1,2)  //1+2i
```

对于一个复数 c =  complex(x, y) ，可以通过Go语言内置函数 real(z) 获得该复数的实
部，也就是 x ，通过 imag(c) 获得该复数的虚部，也就是 y 。

#### 布尔型
在Go语言中，布尔值的类型为 bool，值是 true 或 false,布尔可以做3种逻辑运算，&&（逻辑且），||（逻辑或），！（逻辑非）,布尔类型的值不支持其他类型的转换.

布尔值可以和&&(AND)和||(OR)操作符结合,并且可能会有短路行为:如果运算符左边值已经可以确定整个布尔表达式的值,那么运算符右边的值将不在被求值,因此下面的表达式总是安全的:

```go
 s != "" && s[0] == 'x'
```
其中s[0]操作如果应用于空字符串将会导致panic异常。

#### 字符串
在Go语言中，组成字符串的最小单位是字符，存储的最小单位是字节，字符串本身不支持修改。字节是数据存储的最小单元，每个字节的数据都可以用整数表示，例如一个字节储存的字符a，实际存储的是97而非字符的字形，将这个实际存储的内容用数字表示的类型，称之为byte。

字符串是不可变的字节序列，它可以包含任意数据，包括0值字节，但是主要还是为了人可读的文本。内置的 len()函数返回字符串的字节数。

 字符串的表示法有两种，即：原生表示法和解释型表示法。原生表示法，需用用反引号"`"把字符序列包起来，如果用解释型表示法，则需要用双引号"""包裹字符序列。
 
```go
var str1 string = "keke"
var str2 string = `keke`
 ```
 这两种表示的区别是，前者表示的是所见即所得的(除了回车符)。后者所表示的值中转义符会起作用。字符串值是不可变的，如果我们创建了一个此类型的值，就不可能再对它本身做任何修改。
 
 ```go
var str string  // 声明一个字符串变量
str = "hai keke" // 字符串赋值
ch := str[0] // 取字符串的第一个字符
```

#### 常量
常量表达式的值在编译期计算,而不是在运行期。每种常量的潜在类型都是基础类型:boolean、string或数字。

```go
const x, y int = 1, 2 // 多常量初始化
const s = "Hello, KeKe!" // 类型推断
const ( // 常量组
a, b, c = 10, 20, 30
bool = false
)

func main() {

const m = "20"// 未使用用局部常量不会引发编译错误。
}
```

枚举:关键字 iota 定义常量组中从 0 开始按行行计数的自自增枚举值。

iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。使用iota能简化定义，在定义枚举时很有用。

```go
const (
 Sunday = iota // 0
 Monday // 1,通常省略后续行行表达式。
 Tuesday // 2
 Wednesday // 3
 Thursday // 4
 Friday // 5
 Saturday // 6
)
```
在同一常量组中,可以提供多个 iota,它们各自增⻓。
```go
const (
 A, B = iota, iota << 10 // 0, 0 << 10
 C, D // 1, 1 << 10
)
```
容量大小的单位的自增:
```go
const (
     B = 1 << (10*iota)
     KB
     MB
     GB
     TB
     PB
)
```
bit就是位，也叫比特位，是计算机表示数据最小的单位,byte是字节。`1B（byte，字节,1byte就是1B）= 8 bit(位就是bit也是b)`,一个字符=2字节(2byte)。


#### 整型运算

在整型运算中，算术运算、逻辑运算和比较运算，运算符优先级从上到下递减顺序排列:
```go
 *      /     %     <<     >>     &     &^ 
 +      -     |     ^      
 ==     !=    <     <=     >      >=
 &&
 ||

```
在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序。

bit位操作运算符：

|符号 | 操作             |操作数是否区分符号 |
|-----|-----------------|------------------|
|  &	 | 位运算 AND       |No               | 
|  ^	 | 位运算 XOR       |No               | 
|  &^	| 位清空 (AND NOT) |No               | 
|  <<	| 左移             |Yes              | 
|  >> | 右移             |Yes              | 
